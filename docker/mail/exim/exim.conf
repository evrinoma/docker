######################################################################
#                  Runtime configuration file for Exim               #
######################################################################

########### IMPORTANT ########## IMPORTANT ########### IMPORTANT ###########
#                                                                          #
# Whenever you change Exim's configuration file, you *must* remember to    #
# HUP the Exim daemon, because it will not pick up the new configuration   #
# until you do. However, any other Exim processes that are started, for    #
# example, a process started by an MUA in order to send a message, will    #
# see the new configuration as soon as it is in place.                     #
#                                                                          #
# You do not need to HUP the daemon for changes in auxiliary files that    #
# are referenced from this file. They are read every time they are used.   #
#                                                                          #
# It is usually a good idea to test a new configuration for syntactic      #
# correctness before installing it (for example, by running the command    #
# "exim -C /config/file.new -bV").                                         #
#                                                                          #
########### IMPORTANT ########## IMPORTANT ########### IMPORTANT ###########


######################################################################
## MYSQL CONFIGURATION
######################################################################
 
hide mysql_servers = 172.18.2.1/tools/contrspam/contrspam

MYSQL_Q_RDOMAINS = SELECT domain FROM `mail_domain` LEFT JOIN `mail_server` ON `mail_domain`.`server_id` = `mail_server`.`id` WHERE `mail_server`.`active` = 'a' AND `mail_domain`.`active` = 'a' AND domain='$domain'
MYSQL_Q_WHITELIST = SELECT DISTINCT email FROM `mail_acl` LEFT JOIN `mail_domain` ON `mail_acl`.`domain_id` = `mail_domain`.`id` LEFT JOIN `mail_server` ON `mail_domain`.`server_id` = `mail_server`.`id` WHERE (`mail_server`.`active` = 'a' AND `mail_domain`.`active` = 'a' AND `mail_acl`.`active` = 'a')  AND `mail_domain`.`domain`='${quote_mysql:$domain}' AND `mail_acl`.`type` = 'white' AND ( `mail_acl`.`email` = '${quote_mysql:$sender_address}' OR `mail_acl`.`email` =  '*@${quote_mysql:$sender_address_domain}' )
MYSQL_Q_BLACKLIST = SELECT DISTINCT email FROM `mail_acl` LEFT JOIN `mail_domain` ON `mail_acl`.`domain_id` = `mail_domain`.`id` LEFT JOIN `mail_server` ON `mail_domain`.`server_id` = `mail_server`.`id` WHERE (`mail_server`.`active` = 'a' AND `mail_domain`.`active` = 'a' AND `mail_acl`.`active` = 'a')  AND `mail_domain`.`domain`='${quote_mysql:$domain}' AND `mail_acl`.`type` = 'black' AND ( `mail_acl`.`email` = '${quote_mysql:$sender_address}' OR `mail_acl`.`email` =  '*@${quote_mysql:$sender_address_domain}' )
MYSQL_Q_DOMAIN = SELECT * FROM `mail_domain` LEFT JOIN `mail_server` ON `mail_domain`.`server_id` = `mail_server`.`id` WHERE `mail_server`.`active` = 'a' AND `mail_domain`.`active` = 'a' AND domain='$domain'

######################################################################
#                    MAIN CONFIGURATION SETTINGS                     #
######################################################################

# primary_hostname =


domainlist local_domains = @
domainlist relay_to_domains = mysql;MYSQL_Q_RDOMAINS
#hostlist   relay_from_hosts = 194.186.51.69:127.0.0.1
#hostlist   relay_from_hosts = 81.211.68.180:127.0.0.1
hostlist   relay_from_hosts = 92.62.129.25:127.0.0.1
#write_rejectlog = false
write_rejectlog = true


acl_smtp_rcpt = acl_check_rcpt
acl_smtp_data = acl_check_data


#av_scanner = clamd:/tmp/clamd.socket
#av_scanner = clamd:/var/run/clamd.scan/clamd.sock
av_scanner = clamd:127.0.0.1 3310

spamd_address = 127.0.0.1 783


# Allow any client to use TLS.
tls_advertise_hosts = 
# tls_certificate = /etc/ssl/exim.crt
# tls_privatekey = /etc/ssl/exim.pem

# daemon_smtp_ports = 25 : 465 : 587
# tls_on_connect_ports = 465

# qualify_recipient =
# allow_domain_literals

never_users = root

host_lookup = *

#rfc1413_hosts = *
#rfc1413_query_timeout = 30s


ignore_bounce_errors_after = 1d
timeout_frozen_after = 2d

# split_spool_directory = true


#smtp_banner = $smtp_active_hostname ESMTP Exim \
#  $version_number $tod_full
smtp_banner = "Welcome to ITE-NG Mail Server! $domain $tod_full"

# maximum number of connections from different ip's
smtp_accept_max = 100 

# maximum number of connection per connection
smtp_accept_max_per_connection = 10

# maximum number of connections from one peer
smtp_accept_max_per_host = 10

# size limit
#message_size_limit = 20M
message_size_limit = 50M

# if sender not want wait replay on commands, go off! 
smtp_enforce_sync = true

######################################################################
#                       ACL CONFIGURATION                            #
#         Specifies access control lists for incoming SMTP mail      #
######################################################################

begin acl

######################################################################
## ACL_CHECK_RCPT
######################################################################

acl_check_rcpt:

# Accept if the source is local SMTP (i.e. not over TCP/IP). We do this by
# testing for an empty sending host field.

accept	hosts = :
	control = dkim_disable_verify

deny	message       = Restricted characters in address
	domains       = +local_domains
	local_parts   = ^[.] : ^.*[@%!/|]

deny	message       = Restricted characters in address
	domains       = !+local_domains
	local_parts   = ^[./|] : ^.*[@%!] : ^.*/\\.\\./

#################################################################
## SET 
	warn set acl_m0 = 0s
	warn set acl_m5 = ${lookup mysql{MYSQL_Q_DOMAIN}{$value}}
	warn set acl_m12 = 1 
	#${extract{spamscan}{$acl_m5}}
	warn set acl_m13 = 1
	#${extract{virusscan}{$acl_m5}}
	warn set acl_m17 = 70
	#$${extract{block}{$acl_m5}}
	warn set acl_m18 = 1
	#${extract{reject}{$acl_m5}}

#################################################################
## PRINT OUR MESSAGE
warn
	logwrite = MAIL QUERY REPORT CHECK_RCPT {delay $acl_m0 for $sender_host_name \
	[$sender_host_address] with HELO=$sender_helo_name. Mail \
	from [$sender_address] to [$local_part@$domain]. \
	Sender_host_name=[$sender_host_name] \
	Len_sender_host_name=[${strlen:$sender_host_name}] \
	sender_helo_name=[$sender_helo_name] \
	Len_sender_helo_name=[${strlen:$sender_helo_name}] \
	sender_address_local_part=[$sender_address_local_part] \
	sender_address_domain=[$sender_address_domain] \
	sender_ident=[$sender_ident] \
	original_domain=[$original_domain] \
	return_path=[$return_path] \
	local_part=[$local_part] \
	domain=[$domain] \
	accept=[$acl_m1] \
	delay=[$acl_m0] \
	recipients_count=[$recipients_count] \
	reply_address=[$reply_address] \
	recipients=[$local_part@$domain] \
	mime_filename=[$mime_filename]} END.

#################################################################
## BLACK/WHITE LISTED
#если у сообщения ehlo или host пустое то шлем лесом, даже если доверенный адрес
deny	message = "EHLO AND HOST Name required <$sender_helo_name> <$sender_host_name>"
	condition = ${if or { \
			{eq{${strlen:$sender_helo_name}}{0} } \
			{eq{${strlen:$sender_host_name}}{0} } \
			} {yes}{no} }
	set acl_m1 = 2
	logwrite = RULE 1.1

accept  message = Accepted, $sender_address is in a white list sender_host_address=[$sender_host_address] recipients_count=[$recipients_count] sender_host_name=[$sender_host_name] sender_helo_name=[$sender_helo_name] sender_ident=[$sender_ident] return_path=[$return_path] sender_address_domain=[$sender_address_domain] reply_address=[$reply_address] recipients=[$local_part@$domain] local_part=[$local_part] sender_address_local_part=[$sender_address_local_part]
	senders = mysql;MYSQL_Q_WHITELIST
	set acl_m1 = 1
	logwrite = RULE 1.2

accept	message = Accepted own Domain, $sender_address is in a white list sender_host_address=[$sender_host_address] recipients_count=[$recipients_count] sender_host_name=[$sender_host_name] sender_helo_name=[$sender_helo_name] sender_ident=[$sender_ident] return_path=[$return_path] sender_address_domain=[$sender_address_domain] reply_address=[$reply_address] recipients=[$local_part@$domain] local_part=[$local_part] sender_address_local_part=[$sender_address_local_part]
	condition = ${if eq{1} {${lookup mysql{ \ 
		SELECT DISTINCT count(`mail_domain`.`id`) \
		FROM `mail_domain` \
		LEFT JOIN `mail_server` ON `mail_domain`.`server_id` = `mail_server`.`id` \
		WHERE `mail_server`.`active` = 'a' AND `mail_domain`.`active` = 'a' AND `mail_server`.`hostname`='$sender_helo_name' AND `mail_domain`.`domain`='$sender_address_domain' \
	}}} {yes}{no}}
	set acl_m1 = 1
	logwrite = RULE 1.3

deny	message = [EHLO] Hard rejected, $sender_address is in a black list.
	condition = ${if eq{1} {${lookup mysql{ \
		SELECT DISTINCT count(`mail_spam_rule`.`id`) \
		FROM `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='hard' AND `mail_filter`.`type`='helo' AND '$sender_helo_name' like `mail_spam_rule`.`domain` \
	}}} {yes}{no}}
	condition = ${lookup mysql { \
		UPDATE `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		SET `mail_spam_rule`.`hit` = `mail_spam_rule`.`hit` + 1, `mail_spam_rule`.`update_at` = now() \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='hard' AND `mail_filter`.`type`='helo' AND '$sender_helo_name' like `mail_spam_rule`.`domain` \
	}}
	condition = ${lookup mysql { \
		INSERT INTO `tb_spam_hits` (`id`, `tb_spam_rules`, `time`, `destination`) \
		SELECT DISTINCT NULL, `mail_spam_rule`.`id`, now(), '$local_part@$domain' \
		FROM `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='hard' AND `mail_filter`.`type`='helo' AND '$sender_helo_name' like `mail_spam_rule`.`domain` \
	}}
	set acl_m1 = 2
	logwrite = RULE 1.5

deny	message = [EHLO] Soft rejected, $sender_address is in a black list.
	condition = ${if eq{1} {${lookup mysql{ \
		SELECT DISTINCT count(`mail_spam_rule`.`id`) \
		FROM `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='soft' AND `mail_filter`.`type`='helo' AND '$sender_helo_name' like concat('%',`mail_spam_rule`.`domain`) \
	}}} {yes}{no}}
	condition = ${lookup mysql { \
		UPDATE `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		SET `mail_spam_rule`.`hit` = `mail_spam_rule`.`hit` + 1, `mail_spam_rule`.`update_at` = now() \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='soft' AND `mail_filter`.`type`='helo' AND '$sender_helo_name' like concat('%',`mail_spam_rule`.`domain`) \
	}}
	condition = ${lookup mysql { \
		INSERT INTO `tb_spam_hits` (`id`, `tb_spam_rules`, `time`, `destination`) \
		SELECT DISTINCT NULL, `mail_spam_rule`.`id`, now(), '$local_part@$domain' \
		FROM `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='soft' AND `mail_filter`.`type`='helo' AND '$sender_helo_name' like concat('%',`mail_spam_rule`.`domain`) \
	}}
	set acl_m1 = 2
	logwrite = RULE 1.6

deny	message = [HOST] Hard rejected, $sender_address is in a black list.
	condition = ${if eq{1} {${lookup mysql{ \
		SELECT DISTINCT count(`mail_spam_rule`.`id`) \
		FROM `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='hard' AND `mail_filter`.`type`='host_name' AND '$sender_host_name' like `mail_spam_rule`.`domain` \
	}}} {yes}{no}}
	condition = ${lookup mysql { \
		UPDATE `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		SET `mail_spam_rule`.`hit` = `mail_spam_rule`.`hit` + 1, `mail_spam_rule`.`update_at` = now() \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='hard' AND `mail_filter`.`type`='host_name' AND '$sender_host_name' like `mail_spam_rule`.`domain` \
	}}
	condition = ${lookup mysql { \
		INSERT INTO `tb_spam_hits` (`id`, `tb_spam_rules`, `time`, `destination`) \
		SELECT DISTINCT NULL, `mail_spam_rule`.`id`, now(), '$local_part@$domain' \
		FROM `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='hard' AND `mail_filter`.`type`='host_name' AND '$sender_host_name' like `mail_spam_rule`.`domain` \
	}}
	set acl_m1 = 2
	logwrite = RULE 1.7

deny	message = [HOST] Soft rejected, $sender_address is in a black list.
	condition = ${if eq{1} {${lookup mysql{ \
		SELECT DISTINCT count(`mail_spam_rule`.`id`) \
		FROM `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='soft' AND `mail_filter`.`type`='host_name' AND '$sender_host_name' like concat('%',`mail_spam_rule`.`domain`) \
	}}} {yes}{no}}
	condition = ${lookup mysql { \
		UPDATE `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		SET `mail_spam_rule`.`hit` = `mail_spam_rule`.`hit` + 1, `mail_spam_rule`.`update_at` = now() \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='soft' AND `mail_filter`.`type`='host_name' AND '$sender_host_name' like concat('%',`mail_spam_rule`.`domain`) \
	}}
	condition = ${lookup mysql { \
		INSERT INTO `tb_spam_hits` (`id`, `tb_spam_rules`, `time`, `destination`) \
		SELECT DISTINCT NULL, `mail_spam_rule`.`id`, now(), '$local_part@$domain' \
		FROM `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='soft' AND `mail_filter`.`type`='host_name' AND '$sender_host_name' like concat('%',`mail_spam_rule`.`domain`) \
	}}
	set acl_m1 = 2
	logwrite = RULE 1.8

deny	message = [Return-Path] Hard rejected, $sender_address is in a black list.
	condition = ${if eq{1} {${lookup mysql{ \
		SELECT DISTINCT count(`mail_spam_rule`.`id`) \
		FROM `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='hard' AND `mail_filter`.`type`='Return-Path' AND '$sender_address_domain' like `mail_spam_rule`.`domain` \
	}}} {yes}{no}}
	condition = ${lookup mysql { \
		UPDATE `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		SET `mail_spam_rule`.`hit` = `mail_spam_rule`.`hit` + 1, `mail_spam_rule`.`update_at` = now() \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='hard' AND `mail_filter`.`type`='Return-Path' AND '$sender_address_domain' like `mail_spam_rule`.`domain` \
	}}
	condition = ${lookup mysql { \
		INSERT INTO `tb_spam_hits` (`id`, `tb_spam_rules`, `time`, `destination`) \
		SELECT DISTINCT NULL, `mail_spam_rule`.`id`, now(), '$local_part@$domain' \
		FROM `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='hard' AND `mail_filter`.`type`='Return-Path' AND '$sender_address_domain' like `mail_spam_rule`.`domain` \
	}}
	set acl_m1 = 2
	logwrite = RULE 1.9


deny	message = [Return-Path] Soft rejected, $sender_address is in a black list.
	condition = ${if eq{1} {${lookup mysql{ \
		SELECT DISTINCT count(`mail_spam_rule`.`id`) \
		FROM `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='soft' AND `mail_filter`.`type`='Return-Path' AND '$sender_address_domain' like concat('%',`mail_spam_rule`.`domain`) \
	}}} {yes}{no}}
	condition = ${lookup mysql { \
		UPDATE `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		SET `mail_spam_rule`.`hit` = `mail_spam_rule`.`hit` + 1, `mail_spam_rule`.`update_at` = now() \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='soft' AND `mail_filter`.`type`='Return-Path' AND '$sender_address_domain' like concat('%',`mail_spam_rule`.`domain`) \
	}}
	condition = ${lookup mysql { \
		INSERT INTO `tb_spam_hits` (`id`, `tb_spam_rules`, `time`, `destination`) \
		SELECT DISTINCT NULL, `mail_spam_rule`.`id`, now(), '$local_part@$domain' \
		FROM `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='soft' AND `mail_filter`.`type`='Return-Path' AND '$sender_address_domain' like concat('%',`mail_spam_rule`.`domain`) \
	}}
	set acl_m1 = 2
	logwrite = RULE 1.10

deny	message = [Received] Hard rejected, $sender_address is in a black list.
	condition = ${if eq{1} {${lookup mysql{ \
		SELECT DISTINCT count(`mail_spam_rule`.`id`) \
		FROM `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='hard' AND `mail_filter`.`type`='Received' AND '$sender_host_name' like `mail_spam_rule`.`domain` \
	}}} {yes}{no}}
	condition = ${lookup mysql { \
		UPDATE `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		SET `mail_spam_rule`.`hit` = `mail_spam_rule`.`hit` + 1, `mail_spam_rule`.`update_at` = now() \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='hard' AND `mail_filter`.`type`='Received' AND '$sender_host_name' like `mail_spam_rule`.`domain` \
	}}
	condition = ${lookup mysql { \
		INSERT INTO `tb_spam_hits` (`id`, `tb_spam_rules`, `time`, `destination`) \
		SELECT DISTINCT NULL, `mail_spam_rule`.`id`, now(), '$local_part@$domain' \
		FROM `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='hard' AND `mail_filter`.`type`='Received' AND '$sender_host_name' like `mail_spam_rule`.`domain` \
	}}
	set acl_m1 = 2
	logwrite = RULE 1.11

deny	message = [Received] Soft rejected, $sender_address is in a black list.
	condition = ${if eq{1} {${lookup mysql{ \
		SELECT DISTINCT count(`mail_spam_rule`.`id`) \
		FROM `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='soft' AND `mail_filter`.`type`='Received' AND '$sender_host_name' like concat('%',`mail_spam_rule`.`domain`) \
	}}} {yes}{no}}
	condition = ${lookup mysql { \
		UPDATE `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		SET `mail_spam_rule`.`hit` = `mail_spam_rule`.`hit` + 1, `mail_spam_rule`.`update_at` = now() \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='soft' AND `mail_filter`.`type`='Received' AND '$sender_host_name' like concat('%',`mail_spam_rule`.`domain`) \
	}}
	condition = ${lookup mysql { \
		INSERT INTO `tb_spam_hits` (`id`, `tb_spam_rules`, `time`, `destination`) \
		SELECT DISTINCT NULL, `mail_spam_rule`.`id`, now(), '$local_part@$domain' \
		FROM `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		LEFT JOIN `mail_conformity` ON `mail_spam_rule`.`conformity_id` = `mail_conformity`.`id` \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a' AND `mail_conformity`.`active` = 'a') \
		AND `mail_conformity`.`type`='soft' AND `mail_filter`.`type`='Received' AND '$sender_host_name' like concat('%',`mail_spam_rule`.`domain`) \
	}}
	set acl_m1 = 2
	logwrite = RULE 1.12


deny	message = [Name] Soft rejected, $sender_address is in a black list.
	condition = ${if eq{1} {${lookup mysql{ \
		SELECT DISTINCT count(`mail_spam_rule`.`id`) \
		FROM `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a') \
		AND `mail_filter`.`type`='name' AND '$sender_address_local_part' like concat('%',`mail_spam_rule`.`domain`,'%') AND length('$sender_address_local_part') \
	}}} {yes}{no}}
	condition = ${lookup mysql { \
		UPDATE `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		SET `mail_spam_rule`.`hit` = `mail_spam_rule`.`hit` + 1, `mail_spam_rule`.`update_at` = now() \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a') AND `mail_filter`.`type`='name' AND '$sender_address_local_part' like concat('%',`mail_spam_rule`.`domain`,'%') AND length('$sender_address_local_part') \
	}}
	condition = ${lookup mysql { \
		INSERT INTO `tb_spam_hits` (`id`, `tb_spam_rules`, `time`, `destination`) \
		SELECT DISTINCT NULL, `mail_spam_rule`.`id`, now(), '$sender_host_address' \
		FROM `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a') AND `mail_filter`.`type`='name' AND '$sender_address_local_part' like concat('%',`mail_spam_rule`.`domain`,'%') AND length('$sender_address_local_part') \
	}}

	set acl_m1 = 2
	logwrite = RULE 1.13

deny	message = [Range] 3.3 RCVD_IN_SBL_CSS RBL: Received via a relay in Spamhaus SBL-CSS [$sender_host_address listed in zen.spamhaus.org].
	condition = ${if eq{1} {${lookup mysql{ \
		SELECT DISTINCT count(`mail_spam_rule`.`id`) \
		FROM `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a') \
		AND `mail_filter`.`type`='Range' AND '$sender_host_address' like concat(`mail_spam_rule`.`domain`,'%') \
	}}} {yes}{no}}
	condition = ${lookup mysql { \
		UPDATE `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		SET `mail_spam_rule`.`hit` = `mail_spam_rule`.`hit` + 1, `mail_spam_rule`.`update_at` = now() \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a') AND `mail_filter`.`type`='Range' AND '$sender_host_address' like concat(`mail_spam_rule`.`domain`,'%') \
	}}
	condition = ${lookup mysql { \
		INSERT INTO `tb_spam_hits` (`id`, `tb_spam_rules`, `time`, `destination`) \
		SELECT DISTINCT NULL, `mail_spam_rule`.`id`, now(), '$sender_host_address' \
		FROM `mail_spam_rule` \
		LEFT JOIN `mail_filter` ON `mail_spam_rule`.`type_id` = `mail_filter`.`id` \
		WHERE (`mail_spam_rule`.`active` = 'a' AND `mail_filter`.`active` = 'a') AND `mail_filter`.`type`='Range' AND '$sender_host_address' like concat(`mail_spam_rule`.`domain`,'%') \
	}}
	set acl_m1 = 2
	logwrite = RULE 1.14

deny	message = Rejected, $sender_address is in a black list
	senders = mysql;MYSQL_Q_BLACKLIST
	set acl_m1 = 2
	logwrite = RULE 1.15

#############################################################################
# Accept mail to postmaster in any local domain, regardless of the source,
# and without verifying the sender.

accept local_parts   = postmaster
       domains       = +local_domains

deny local_parts   = all

 # Deny unless the sender address can be verified.

require verify        = sender


accept hosts         = +relay_from_hosts
       control       = submission


accept  authenticated = *
        control       = submission


require message = relay not permitted
        domains = +local_domains : +relay_to_domains


##################################################################
## Scan HELO

# Запрещаем тех, кто не обменивается приветственными сообщениями (HELO/EHLO)
deny	message = "HELO/EHLO required by SMTP RFC ($acl_m10)"
	condition = ${if eq{$sender_helo_name}{}{yes}{no}}
	set acl_m1 = 2
	logwrite = RULE 2.1

# Запрещаем тех, кто в HELO "отдает" только цифры.
deny	condition     = ${if match{$sender_helo_name}{\N^\d+$\N}{yes}{no}}
	hosts         = !127.0.0.1:!localhost:*
	message       = "There can not be only numbers in HELO!"
	set acl_m1 = 2
	logwrite = RULE 2.2

# Запрещаем тех, кто в HELO "отдает" не правильно.
deny	message = "Invalid domain or IP given in HELO/EHLO ($acl_m10)"
	!condition = ${if match{$sender_helo_name}{\\\.}{yes}{no}}
	set acl_m1 = 2
	logwrite = RULE 2.3

# Запрещаем тех, кто в HELO наш адрес
deny	message = Forged IP detected in HELO (it's mine) - $sender_helo_name ($acl_m10)
	hosts = !+relay_from_hosts
	condition = ${if eq{$sender_helo_name}{$interface_address}{yes}{no}}
	set acl_m1 = 2
	logwrite = RULE 2.4

# Удаленный не может быть localhost or localdomain
deny	message = $sender_helo_name is a silly HELO. ($acl_m10)
	hosts   = !+relay_from_hosts
	condition = ${if match{$sender_helo_name}{\N^(127\.0\.0\.1|localhost(\.localdomain)?)$\N}{yes}{no}}
	set acl_m1 = 2
	logwrite = RULE 2.5

# 
deny	message = Forged IP detected in HELO - $sender_helo_name != $sender_host_address ($acl_m10)
	hosts = !+relay_from_hosts
	condition = ${if match{$sender_helo_name}{\N^\d+(\.\d+){3}$\N} {yes}{no}}
	condition = ${if eq{$sender_helo_name}{$sender_host_address} {no}{yes}}
	set acl_m1 = 2
	logwrite = RULE 2.6

#
deny	message = Forged hostname detected in HELO - $sender_helo_name ($acl_m10)
	# accept helo which is in local_domain if we relay or had smtp auth
	hosts = !+relay_from_hosts
	!authenticated = *
	log_message = Forged hostname detected in HELO - $sender_helo_name ($acl_m10)
	condition = ${if match_domain{$sender_helo_name}{+local_domains} {yes}{no}}
	set acl_m1 = 2
	logwrite = RULE 2.7

##################################################################
## Scan HOST NAME

# Запрещаем тех, кто не обменивается приветственными сообщениями (HELO/EHLO)
deny	message = "HOSTNAME required by SMTP RFC ($acl_m10) ver1.1"
	condition = ${if eq{${strlen:$sender_host_name}}{0}{yes}{no}}
	set acl_m1 = 2
	logwrite = RULE 2.8

require verify = recipient

warn
	hosts = +relay_from_hosts 
	set acl_m0 = 0s

deny	message = rejected because $sender_host_address ($acl_m10) is in a black list at $dnslist_domain\n$dnslist_text
	dnslists = bl.spamcop.net : \
		cbl.abuseat.org : \
		zen.spamhaus.org
	logwrite = RULE 2.9

accept

######################################################################
## ACL_CHECK_MIME
######################################################################

acl_check_mime:

# Запрещаем вложения определенных типов
deny	message = Blacklisted file extension detected ($mime_filename)
	condition = ${if match {${lc:$mime_filename}} {\N(\.exe|\.pif|\.bat|\.scr|\.lnk|\.com|\.vbs|\.cpl)$\N}{1}{0}}
	logwrite = RULE 3.1

accept 

######################################################################
## ACL_CHECK_DATA
######################################################################

acl_check_data:

#################################################################
## PRINT OUR MESSAGE
warn
	logwrite =  CHECK_DATA { \
	Mail from [$sender_address] to [$local_part@$domain]. \
	Sender_host_name=[$sender_host_name] \
	sender_helo_name=[$sender_helo_name] \
	sender_address_local_part=[$sender_address_local_part] \
	sender_address_domain=[$sender_address_domain] \
	sender_ident=[$sender_ident] \
	accept=[$acl_m1] \
	original_domain=[$original_domain] \
	return_path=[$return_path] \
	recipients_count=[$recipients_count] \
	reply_address=[$reply_address] \
	recipients=[$local_part@$domain] } END.

#################################################################
## BLACK/WHITE LISTED
accept	condition = ${if eq{$acl_m1}{1} {true}}
	message = Accepted, [$sender_address] is in a white list
	logwrite = RULE 4.1

# Запрещаем тех, кто у кого нет Return Path он не из нашего домена и это не MAILER-DAEMON
deny	message = "Return Path required <$return_path>"
	condition = ${if and { \
			{eq{${strlen:$return_path}}{0} } \
			{match{${uc:$reply_address}}{MAILER-DAEMON}} \
			{eq{1} {${lookup mysql{ \
				SELECT DISTINCT count(`mail_domain`.`id`) \
				FROM `mail_domain` \
				LEFT JOIN `mail_server` ON `mail_domain`.`server_id` = `mail_server`.`id` \
				WHERE `mail_server`.`active` = 'a' AND `mail_domain`.`active` = 'a' AND `mail_server`.`hostname`='$sender_helo_name' \
				}}}} \
			} {yes}{no} }
	set acl_m1 = 2
	logwrite = RULE 4.2

deny	condition = ${if eq{$acl_m1}{2} {true}}
	message = Rejected, [$sender_address] is in a black list
	logwrite = RULE 4.3

deny	condition = ${if eq{$acl_m13}{1} {true}}
	malware    = *
	message    = This message contains a virus [$malware_name].
	logwrite = RULE 4.4

deny	condition = ${if eq{$acl_m12}{1} {true}}
	condition = ${if <{$message_size}{80k}{1}{0}}
	spam      = nobody:true
	condition = ${if >{$spam_score_int}{$acl_m17}{1}{0}}
	message = Your message scored [$spam_score_int] SpamAssassin point. Report follows: [$spam_report]
	add_header = X-Spam-Report-X: $spam_report
	condition = ${if eq{$acl_m18}{1} {true}}
	logwrite = RULE 4.5

#deny	message = SPAM! <Return-path> domain is not equals to <From> sender_helo_name=[$sender_helo_name] domain=[$domain] ext=[${uc:${domain:$sender_address}}]
#	# Сравниваем домены From и Return-path
#	condition = ${if eq{${uc:${domain:$sender_address}}} {${uc:${domain:$h_From:}}} {no}{yes}}

#deny	message = SPAM! <From> is Empty sender_helo_name=[$sender_helo_name] domain=[$domain] h_From=[$h_From]
#	# Поле From не должно быть пустым
#	condition = ${if eq{$h_From:}{} {no}{yes}}

#deny	message = SPAM! <Domain> not own sender_helo_name=[$sender_helo_name] domain=[$domain] h_From=[$h_From] ext=[${uc:$sender_helo_name}]
#	# Сравниваем, что сервер обслуживает этот домен
#	condition = ${if !eq{0} {${lookup mysql{SELECT DISTINCT count(`mail_domain`.`id`) FROM `mail_domain` LEFT JOIN `mail_server` ON `mail_domain`.`server_id` = `mail_server`.`id` WHERE `mail_server`.`active` = 'a' AND `mail_domain`.`active` = 'a' AND `mail_server`.`hostname`='$sender_helo_name'}}} {no}{yes}}
#	#condition = ${lookup mysql{SELECT `mail_domain`.`domain` FROM `mail_domain` LEFT JOIN `mail_server` ON `mail_domain`.`server_id` = `mail_server`.`id` WHERE ( `mail_server`.`active` = 'a' AND `mail_domain`.`active` = 'a' ) AND `mail_domain`.`domain`='${domain:$h_From:}'} {yes}{no}}

#	deny	message = SPAM! To and CC error
#	perl
#	condition = ${if eq{${perl{/opt/exim/etc/t.pl} {$h_Cc:} {$h_To:}} {1} {no}{yes}}
#	condition = ${if eq{${perl{/opt/exim/etc/t.pl}} {1} {yes}{no}}


accept


######################################################################
#                      ROUTERS CONFIGURATION                         #
#               Specifies how addresses are handled                  #
######################################################################
#     THE ORDER IN WHICH THE ROUTERS ARE DEFINED IS IMPORTANT!       #
# An address is passed to each router in turn until it is accepted.  #
######################################################################

begin routers

iteng_router:
    driver = "manualroute"
    transport = remote_smtp
    route_data = ${extract{ip}{${lookup mysql {MYSQL_Q_DOMAIN}{$value}}}}
	    

# This router routes to remote hosts over SMTP by explicit IP address,
# when an email address is given in "domain literal" form, for example,
# <user@[192.168.35.64]>. The RFCs require this facility. However, it is
# little-known these days, and has been exploited by evil people seeking
# to abuse SMTP relays. Consequently it is commented out in the default
# configuration. If you uncomment this router, you also need to uncomment
# allow_domain_literals above, so that Exim can recognize the syntax of
# domain literal addresses.

# domain_literal:
#   driver = ipliteral
#   domains = ! +local_domains
#   transport = remote_smtp


# This router routes addresses that are not in local domains by doing a DNS
# lookup on the domain name. The exclamation mark that appears in "domains = !
# +local_domains" is a negating operator, that is, it can be read as "not". The
# recipient's domain must not be one of those defined by "domainlist
# local_domains" above for this router to be used.
#
# If the router is used, any domain that resolves to 0.0.0.0 or to a loopback
# interface address (127.0.0.0/8) is treated as if it had no DNS entry. Note
# that 0.0.0.0 is the same as 0.0.0.0/32, which is commonly treated as the
# local host inside the network stack. It is not 0.0.0.0/0, the default route.
# If the DNS lookup fails, no further routers are tried because of the no_more
# setting, and consequently the address is unrouteable.

dnslookup:
  driver = dnslookup
  domains = ! +local_domains
  transport = remote_smtp
  ignore_target_hosts = 0.0.0.0 : 127.0.0.0/8
  no_more


# The remaining routers handle addresses in the local domain(s), that is those
# domains that are defined by "domainlist local_domains" above.


# This router handles aliasing using a linearly searched alias file with the
# name /etc/aliases. When this configuration is installed automatically,
# the name gets inserted into this file from whatever is set in Exim's
# build-time configuration. The default path is the traditional /etc/aliases.
# If you install this configuration by hand, you need to specify the correct
# path in the "data" setting below.
#
##### NB  You must ensure that the alias file exists. It used to be the case
##### NB  that every Unix had that file, because it was the Sendmail default.
##### NB  These days, there are systems that don't have it. Your aliases
##### NB  file should at least contain an alias for "postmaster".
#
# If any of your aliases expand to pipes or files, you will need to set
# up a user and a group for these deliveries to run under. You can do
# this by uncommenting the "user" option below (changing the user name
# as appropriate) and adding a "group" option if necessary. Alternatively, you
# can specify "user" on the transports that are used. Note that the transports
# listed below are the same as are used for .forward files; you might want
# to set up different ones for pipe and file deliveries from aliases.

system_aliases:
  driver = redirect
  allow_fail
  allow_defer
  data = ${lookup{$local_part}lsearch{/etc/aliases}}
# user = exim
  file_transport = address_file
  pipe_transport = address_pipe


# This router handles forwarding using traditional .forward files in users'
# home directories. If you want it also to allow mail filtering when a forward
# file starts with the string "# Exim filter" or "# Sieve filter", uncomment
# the "allow_filter" option.

# If you want this router to treat local parts with suffixes introduced by "-"
# or "+" characters as if the suffixes did not exist, uncomment the two local_
# part_suffix options. Then, for example, xxxx-foo@your.domain will be treated
# in the same way as xxxx@your.domain by this router. You probably want to make
# the same change to the localuser router.

# The no_verify setting means that this router is skipped when Exim is
# verifying addresses. Similarly, no_expn means that this router is skipped if
# Exim is processing an EXPN command.

# The check_ancestor option means that if the forward file generates an
# address that is an ancestor of the current one, the current one gets
# passed on instead. This covers the case where A is aliased to B and B
# has a .forward file pointing to A.

# The three transports specified at the end are those that are used when
# forwarding generates a direct delivery to a file, or to a pipe, or sets
# up an auto-reply, respectively.

userforward:
  driver = redirect
  check_local_user
# local_part_suffix = +* : -*
# local_part_suffix_optional
  file = $home/.forward
# allow_filter
  no_verify
  no_expn
  check_ancestor
  file_transport = address_file
  pipe_transport = address_pipe
  reply_transport = address_reply


# This router matches local user mailboxes. If the router fails, the error
# message is "Unknown user".

# If you want this router to treat local parts with suffixes introduced by "-"
# or "+" characters as if the suffixes did not exist, uncomment the two local_
# part_suffix options. Then, for example, xxxx-foo@your.domain will be treated
# in the same way as xxxx@your.domain by this router.

localuser:
  driver = accept
  check_local_user
# local_part_suffix = +* : -*
# local_part_suffix_optional
  transport = local_delivery
  cannot_route_message = Unknown user



######################################################################
#                      TRANSPORTS CONFIGURATION                      #
######################################################################
#                       ORDER DOES NOT MATTER                        #
#     Only one appropriate transport is called for each delivery.    #
######################################################################

# A transport is used only when referenced from a router that successfully
# handles an address.

begin transports


# This transport is used for delivering messages over SMTP connections.

remote_smtp:
  driver = smtp
  
  DKIM_DOMAIN = ${lc:${domain:$h_from:}}
  DKIM_FILE = /opt/exim/dkim/${lc:${domain:$h_from:}}.pem
  DKIM_PRIVATE_KEY = ${if exists{DKIM_FILE}{DKIM_FILE}{0}}
  DKIM_SELECTOR = mail
  DKIM_CANON = relaxed

# This transport is used for local delivery to user mailboxes in traditional
# BSD mailbox format. By default it will be run under the uid and gid of the
# local user, and requires the sticky bit to be set on the /var/mail directory.
# Some systems use the alternative approach of running mail deliveries under a
# particular group instead of using the sticky bit. The commented options below
# show how this can be done.

local_delivery:
  driver = appendfile
  file = /var/mail/$local_part
  delivery_date_add
  envelope_to_add
  return_path_add
# group = mail
# mode = 0660


# This transport is used for handling pipe deliveries generated by alias or
# .forward files. If the pipe generates any standard output, it is returned
# to the sender of the message as a delivery error. Set return_fail_output
# instead of return_output if you want this to happen only when the pipe fails
# to complete normally. You can set different transports for aliases and
# forwards if you want to - see the references to address_pipe in the routers
# section above.

address_pipe:
  driver = pipe
  return_output


# This transport is used for handling deliveries directly to files that are
# generated by aliasing or forwarding.

address_file:
  driver = appendfile
  delivery_date_add
  envelope_to_add
  return_path_add


# This transport is used for handling autoreplies generated by the filtering
# option of the userforward router.

address_reply:
  driver = autoreply



######################################################################
#                      RETRY CONFIGURATION                           #
######################################################################

begin retry

# This single retry rule applies to all domains and all errors. It specifies
# retries every 15 minutes for 2 hours, then increasing retry intervals,
# starting at 1 hour and increasing each time by a factor of 1.5, up to 16
# hours, then retries every 6 hours until 4 days have passed since the first
# failed delivery.

# WARNING: If you do not have any retry rules at all (this section of the
# configuration is non-existent or empty), Exim will not do any retries of
# messages that fail to get delivered at the first attempt. The effect will
# be to treat temporary errors as permanent. Therefore, DO NOT remove this
# retry rule unless you really don't want any retries.

# Address or Domain    Error       Retries
# -----------------    -----       -------

*                      *           F,2h,15m; G,16h,1h,1.5; F,4d,6h



######################################################################
#                      REWRITE CONFIGURATION                         #
######################################################################

# There are no rewriting specifications in this default configuration file.

begin rewrite



######################################################################
#                   AUTHENTICATION CONFIGURATION                     #
######################################################################

# The following authenticators support plaintext username/password
# authentication using the standard PLAIN mechanism and the traditional
# but non-standard LOGIN mechanism, with Exim acting as the server.
# PLAIN and LOGIN are enough to support most MUA software.
#
# These authenticators are not complete: you need to change the
# server_condition settings to specify how passwords are verified.
# They are set up to offer authentication to the client only if the
# connection is encrypted with TLS, so you also need to add support
# for TLS. See the global configuration options section at the start
# of this file for more about TLS.
#
# The default RCPT ACL checks for successful authentication, and will accept
# messages from authenticated users from anywhere on the Internet.

begin authenticators

# PLAIN authentication has no server prompts. The client sends its
# credentials in one lump, containing an authorization ID (which we do not
# use), an authentication ID, and a password. The latter two appear as
# $auth2 and $auth3 in the configuration and should be checked against a
# valid username and password. In a real configuration you would typically
# use $auth2 as a lookup key, and compare $auth3 against the result of the
# lookup, perhaps using the crypteq{}{} condition.

#PLAIN:
#  driver                     = plaintext
#  server_set_id              = $auth2
#  server_prompts             = :
#  server_condition           = Authentication is not yet configured
#  server_advertise_condition = ${if def:tls_cipher }

# LOGIN authentication has traditional prompts and responses. There is no
# authorization ID in this mechanism, so unlike PLAIN the username and
# password are $auth1 and $auth2. Apart from that you can use the same
# server_condition setting for both authenticators.

#LOGIN:
#  driver                     = plaintext
#  server_set_id              = $auth1
#  server_prompts             = <| Username: | Password:
#  server_condition           = Authentication is not yet configured
#  server_advertise_condition = ${if def:tls_cipher }


######################################################################
#                   CONFIGURATION FOR local_scan()                   #
######################################################################

# If you have built Exim to include a local_scan() function that contains
# tables for private options, you can define those options here. Remember to
# uncomment the "begin" line. It is commented by default because it provokes
# an error with Exim binaries that are not built with LOCAL_SCAN_HAS_OPTIONS
# set in the Local/Makefile.

# begin local_scan


# End of Exim configuration file
